'use strict';

var estreeParse = require('./babylon-parser');

var traverse = require('@babel/traverse').default;
var isStyled = require('../utils/styled').isStyled;
var isHelper = require('../utils/styled').isHelper;
var isStyledImport = require('../utils/styled').isStyledImport;
var hasAttrsCall = require('../utils/styled').hasAttrsCall;
var getAttrsObject = require('../utils/styled').getAttrsObject;
var isExtendCall = require('../utils/styled').isExtendCall;
var wrapSelector = require('../utils/general').wrapSelector;
var wrapKeyframes = require('../utils/general').wrapKeyframes;
var fixIndentation = require('../utils/general').fixIndentation;
var removeBaseIndentation = require('../utils/general').removeBaseIndentation;
var isStylelintComment = require('../utils/general').isStylelintComment;

var getTTLContent = require('../utils/tagged-template-literal.js').getTaggedTemplateLiteralContent;
var parseImports = require('../utils/parse').parseImports;
var getSourceMap = require('../utils/parse').getSourceMap;

var processStyledComponentsFile = function processStyledComponentsFile(ast, absolutePath, options) {
  var extractedCSS = [];
  var ignoreRuleComments = [];
  var importedNames = {
    default: 'styled',
    css: 'css',
    keyframes: 'keyframes',
    injectGlobal: 'injectGlobal'
  };
  var sourceMap = {};
  var interpolationLines = [];
  traverse(ast, {
    noScope: true,
    enter(_ref) {
      var node = _ref.node;

      if (node.type !== 'Program' && node.leadingComments) {
        node.leadingComments.forEach(function (comment) {
          if (isStylelintComment(comment.value)) {
            ignoreRuleComments.push(`/*${comment.value}*/`);
          }
        });
      }
      if (isStyledImport(node, options.moduleName)) {
        importedNames = parseImports(node);
        return;
      }
      var helper = isHelper(node, importedNames);
      var processedNode = Object.assign({}, node);
      if (hasAttrsCall(node)) {
        processedNode.tag = getAttrsObject(node);
      }
      if (!helper && !isStyled(processedNode, importedNames.default) && !isExtendCall(node)) {
        return;
      }
      var content = getTTLContent(node, absolutePath);
      var fixedContent = fixIndentation(content).text;
      var wrappedContent = void 0;
      switch (helper) {
        case 'keyframes':
          // wrap it in a @keyframes block
          wrappedContent = wrapKeyframes(fixedContent);
          break;

        case 'injectGlobal':
          // Don't wrap it as it goes in global scope, but put it to
          // base line to avoid indentation errors
          wrappedContent = removeBaseIndentation(fixedContent);
          break;

        default:
          // Wrap it in a dummy selector as this is what Styled Components would do
          wrappedContent = wrapSelector(fixedContent);
      }
      var stylelintCommentsAdded = ignoreRuleComments.length > 0 ? `${ignoreRuleComments.join('\n')}\n${wrappedContent}` : wrappedContent;
      extractedCSS.push(stylelintCommentsAdded);
      sourceMap = Object.assign(sourceMap, getSourceMap(extractedCSS.join('\n'), wrappedContent, processedNode.quasi.loc.start.line));
      // Save dummy interpolation lines
      node.quasi.expressions.forEach(function (expression, i) {
        // Skip the end line of previous text
        // because the indentation is not generated by substitution
        var l = node.quasi.quasis[i].loc.end.line + 1;
        while (l <= node.quasi.quasis[i + 1].loc.start.line) {
          interpolationLines.push(l);
          l += 1;
        }
      });

      /**
       * All queued comments have been added to the file so we don't need to, and actually shouldn't
       * add them to the file more than once
       */
      ignoreRuleComments = [];
    }
  });

  return {
    extractedCSS: extractedCSS.join('\n'),
    interpolationLines,
    sourceMap
  };
};

module.exports = function (input, absolutePath, options) {
  var typedParser = absolutePath.endsWith('.ts') || absolutePath.endsWith('.tsx') ? 'typescript' : 'flow';
  var ast = estreeParse(typedParser)(input);
  return processStyledComponentsFile(ast, absolutePath, options);
};