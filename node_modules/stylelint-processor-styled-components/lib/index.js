'use strict';

var path = require('path');
var parse = require('./parsers/index');

var inputId = 1;
var interpolationLinesMap = {};
var sourceMapsCorrections = {};
var errorWasThrown = {};
var DEFAULT_OPTIONS = {
  moduleName: 'styled-components'
};

module.exports = function (options) {
  return {
    // Get string for stylelint to lint
    code(input, filepath) {
      var absolutePath = void 0;
      if (filepath) {
        absolutePath = path.resolve(process.cwd(), filepath);
      } else {
        absolutePath = `<input css ${inputId}>`;
        inputId += 1;
      }

      try {
        sourceMapsCorrections[absolutePath] = {};

        var _parse = parse(input, absolutePath, Object.assign({}, DEFAULT_OPTIONS, options)),
            extractedCSS = _parse.extractedCSS,
            interpolationLines = _parse.interpolationLines,
            sourceMap = _parse.sourceMap;
        // Save dummy interpolation lines


        interpolationLinesMap[absolutePath] = interpolationLines.concat(interpolationLinesMap[absolutePath] || []);
        // Save source location, merging existing corrections with current corrections
        sourceMapsCorrections[absolutePath] = Object.assign(sourceMapsCorrections[absolutePath], sourceMap);
        return extractedCSS;
      } catch (e) {
        // incorrect interpolations will throw CssSyntaxError and they'll be handled by stylelint
        if (e.name === 'CssSyntaxError') {
          errorWasThrown[absolutePath] = true;
          throw e;
        }
        return '';
      }
    },
    // Fix sourcemaps
    result(stylelintResult, filepath) {
      if (errorWasThrown[filepath]) {
        // We threw an error ourselves, in this case we have already put correct
        // line/column numbers so no source maps are needed
        // (and would actually break the line numbers)
        delete errorWasThrown[filepath];
        return stylelintResult;
      }
      var interpolationLines = interpolationLinesMap[filepath] || [];
      var lineCorrection = sourceMapsCorrections[filepath];
      var warnings = stylelintResult.warnings.filter(function (warning) {
        return (
          // Filter indentation warnings generated by interpolations substitution
          !(warning.rule === 'indentation' && interpolationLines.indexOf(lineCorrection[warning.line]) >= 0)
        );
      }).map(function (warning) {
        return Object.assign({}, warning, {
          // Replace "brace" with "backtick" in warnings, e.g.
          // "Unexpected empty line before closing backtick" (instead of "brace")
          text: warning.text.replace(/brace/, 'backtick'),
          line: lineCorrection[warning.line]
        });
      });

      var result = Object.assign({}, stylelintResult, { warnings });
      // Undo `errored` if no warnings with error severity any more
      if (result.errored && !warnings.some(function (warning) {
        return warning.severity === 'error';
      })) {
        delete result.errored;
      }
      return result;
    }
  };
};